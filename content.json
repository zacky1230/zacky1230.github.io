{"pages":[],"posts":[{"title":"游戏玩法分析","text":"题目描述游戏玩法分析 活动表 Activity： 12345678+--------------+---------+| Column Name | Type |+--------------+---------+| player_id | int || device_id | int || event_date | date || games_played | int |+--------------+---------+ 表的主键是 (player_id, event_date)。这张表展示了一些游戏玩家在游戏平台上的行为活动。每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后 打开的游戏的数目（可能是 0 个）。 写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。查询结果的格式如下所示: 12345678910111213141516171819Activity 表：+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-05-02 | 6 || 2 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result 表：+-----------+-------------+| player_id | first_login |+-----------+-------------+| 1 | 2016-03-01 || 2 | 2017-06-25 || 3 | 2016-03-02 |+-----------+-------------+ 解决方案12SELECT player_id, min(event_date) first_login FROM Activity GROUP BY player_id; 题目描述 写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。查询结果的格式如下所示: 12345678910111213141516171819Activity table:+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-05-02 | 6 || 2 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result table:+-----------+-----------+| player_id | device_id |+-----------+-----------+| 1 | 2 || 2 | 3 || 3 | 1 |+-----------+-----------+ 解决方案1234SELECT player_id,device_id FROM Activity WHERE (player_id, event_date)IN (SELECT player_id, min(event_date) first_loginFROM Activity GROUP BY player_id ); 题目描述 编写一个 SQL 查询，同时报告每组玩家和日期，以及玩家到目前为止玩了多少游戏。也就是说，在此日期之前玩家所玩的游戏总数。详细情况请查看示例。查询结果格式如下所示： 12345678910111213141516171819202122232425Activity table:+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-05-02 | 6 || 1 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result table:+-----------+------------+---------------------+| player_id | event_date | games_played_so_far |+-----------+------------+---------------------+| 1 | 2016-03-01 | 5 || 1 | 2016-05-02 | 11 || 1 | 2017-06-25 | 12 || 3 | 2016-03-02 | 0 || 3 | 2018-07-03 | 5 |+-----------+------------+---------------------+对于 ID 为 1 的玩家，2016-05-02 共玩了 5+6=11 个游戏，2017-06-25 共玩了 5+6+1=12 个游戏。对于 ID 为 3 的玩家，2018-07-03 共玩了 0+5=5 个游戏。请注意，对于每个玩家，我们只关心玩家的登录日期。 解决方案12345678910SELECT a1.player_id,a1.event_date,sum(a2.games_played) games_played_so_farFROMactivity a1,activity a2WHEREa1.player_id=a2.player_idANDa1.event_date&gt;=a2.event_dateGROUP BY a1.player_id,a1.event_dateORDER BY player_id,event_date 题目描述 编写一个 SQL 查询，报告在首次登录的第二天再次登录的玩家的比率，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。查询结果格式如下所示： 123456789101112131415161718Activity table:+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-03-02 | 6 || 2 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result table:+-----------+| fraction |+-----------+| 0.33 |+-----------+只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33 解决方案1234SELECT ROUND(sum(case when datediff(a.event_date,b.first_date)=1 then 1 else 0 end)/(select count(distinct(player_id)) from activity),2) as fractionfrom activity a,(select player_id,min(event_date) first_date from activity group by player_id) bwhere a.player_id=b.player_id","link":"/2021/06/20/%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E5%88%86%E6%9E%90/"},{"title":"设计千万级用户排名系统","text":"场景 某海量用户网站，用户拥有积分，积分可能会在使用过程中随时更新。现在要为该网站设计一种算法，在每次用户登录时显示其当前积分排名。用户最大规模为2亿；积分为非负整数，且小于100万。 设计思路解决方案存在问题","link":"/2021/06/11/%E8%AE%BE%E8%AE%A1%E5%8D%83%E4%B8%87%E7%BA%A7%E7%94%A8%E6%88%B7%E6%8E%92%E5%90%8D%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"系统设计","slug":"系统设计","link":"/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}]}