{"pages":[{"title":"","text":"","link":"/README.html"}],"posts":[{"title":"开发者知识技能树","text":"知识点梳理 改栏目主要用于梳理开发者常见技能。","link":"/2021/06/20/%E5%BC%80%E5%8F%91%E8%80%85%E7%9F%A5%E8%AF%86%E6%8A%80%E8%83%BD%E6%A0%91/"},{"title":"设计千万级用户排名系统","text":"场景 某海量用户网站，用户拥有积分，积分可能会在使用过程中随时更新。现在要为该网站设计一种算法，在每次用户登录时显示其当前积分排名。用户最大规模为2亿；积分为非负整数，且小于100万。 设计思路解决方案存在问题","link":"/2021/06/11/%E8%AE%BE%E8%AE%A1%E5%8D%83%E4%B8%87%E7%BA%A7%E7%94%A8%E6%88%B7%E6%8E%92%E5%90%8D%E7%B3%BB%E7%BB%9F/"},{"title":"Redis In Action 笔记（一）","text":"本文是对 Redis In Action 一书的内容进行了个人知识的梳理和总结。 Redis 概念 Redis 是一个远程内存数据库，它提供了5种不同的类型的数据结构，可以支持复制、持久化和客户端分片等功能。 Redis同其他数据库之间的对比 Redis 数据结构 String 常见命令 List 常见命令 Hash 常见命令 Set 常见命令 SortedSet(ZSet) 常见命令 持久化及复制 持久化选项可以让用户将自己的数据存储到硬盘上面，复制特性保证更新数据副本存储到附加的机器上面，来提升系统的性能和数据的可靠性。 快照 Redis 通过创建快照来获得存储在内存里面的数据在某个时间点的副本。在创建快照后，用户可以对快照进行备份，将快照复制到其他服务器从而创建具有相同的数据的服务器副本，也可以将快照留在原地以便重启服务器使用。 AOF AOF 持久化将被执行的写命令写到AOF文件的尾部，来记录数据发生的变化。","link":"/2021/06/27/Redis-In-Action-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"阿里云Flink实时计算DEMO","text":"统计网站实时充值数据情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136-- 日志CREATE TEMPORARY TABLE sls_table_temp ( __event__ STRING, __event__app__ STRING, __event__time__ BIGINT, ts AS TO_TIMESTAMP (FROM_UNIXTIME (__event__time__)), WATERMARK FOR ts AS ts - INTERVAL '2' SECOND --为Rowtime定义Watermark。 )with ( 'connector' = 'sls', 'endpoint' = '', 'accessId' = '', 'accessKey' = '', 'project' = '', 'logstore' = '', 'startTime' = '' );-- 订单表CREATE TEMPORARY VIEW order_table_temp ASSELECT event_name, JSON_VALUE (event_str, '$.et.ai.si') AS site_id, JSON_VALUE (event_str, '$.et.ai.li') AS link_id, JSON_VALUE (event_str, '$.et.kv.orderNum') AS order_num, JSON_VALUE (event_str, '$.et.kv.amount') AS amount, JSON_VALUE (event_str, '$.et.kv.chapterId') AS chapter_id, JSON_VALUE (event_str, '$.et.kv.activityId') AS activity_id, JSON_VALUE (event_str, '$.et.kv.pushId') AS push_id, JSON_VALUE (event_str, '$.et.kv.page') AS page, JSON_VALUE (event_str, '$.et.kv.type') AS order_type, JSON_VALUE (event_str, '$.et.kv.bookId') AS book_id, FROM_UNIXTIME ( CAST ( JSON_VALUE (event_str, '$.et.kv.orderTime') AS BIGINT ) / 1000 ) order_time, appfrom ( select __event__ AS event_str, JSON_VALUE (__event__, '$.app') AS app, JSON_VALUE (__event__, '$.et.en') AS event_name from sls_table_temp )where app = 'matrix_app' AND event_name = 'order';-- 充值表CREATE TEMPORARY VIEW recharge_table_temp ASSELECT event_name, JSON_VALUE (event_str, '$.et.kv.isFirst') AS is_first, JSON_VALUE (event_str, '$.et.kv.uid') AS user_id, JSON_VALUE (event_str, '$.et.kv.orderNum') AS order_num, JSON_VALUE (event_str, '$.et.kv.status') AS recharge_status, FROM_UNIXTIME ( CAST ( JSON_VALUE (event_str, '$.et.kv.rechargeTime') AS BIGINT ) / 1000 ) recharge_time, appfrom ( select __event__ AS event_str, JSON_VALUE (__event__, '$.app') AS app, JSON_VALUE (__event__, '$.et.en') AS event_name from sls_table_temp )where app = 'matrix_app' AND event_name = 'recharge';-- 双表联合CREATE TEMPORARY VIEW user_order_recharge_temp ASselect *from order_table_temp o left join recharge_table_temp r on o.order_num = r.order_num;-- 统计SELECT site_id, SUM ( CASE WHEN recharge_status = 1 AND order_type = 'normal' THEN amount ELSE 0 END ) normal_recharge_amount, COUNT ( DISTINCT CASE WHEN recharge_status = 1 AND order_type = 'normal' THEN user_id END ) normal_recharge_users, SUM ( CASE WHEN recharge_status = 1 AND order_type = 'normal' THEN 1 ELSE 0 END ) normal_orders, SUM ( CASE WHEN recharge_status IS NULL AND order_type = 'normal' THEN 1 ELSE 0 END ) normal_orders_not_pay, SUM ( CASE WHEN recharge_status = 1 AND order_type = 'monthly' THEN amount ELSE 0 END ) vip_recharge_amount, COUNT ( DISTINCT CASE WHEN recharge_status = 1 AND order_type = 'monthly' THEN user_id END ) vip_recharge_users, SUM ( CASE WHEN recharge_status = 1 AND order_type = 'monthly' THEN 1 ELSE 0 END ) vip_orders, SUM ( CASE WHEN recharge_status IS NULL AND order_type = 'monthly' THEN 1 ELSE 0 END ) vip_orders_not_payfrom user_order_recharge_tempgroup by site_id;","link":"/2021/06/21/%E9%98%BF%E9%87%8C%E4%BA%91Flink%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97DEMO/"},{"title":"深入理解Java集合类","text":"理解Java集合 Java集合工具类继承关系图。从下图中能发现Map并没有实现Collection接口，其实现了Map接口。 Iterable 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。 Collection 继承Iterable接口，不能被实例化。 List ArrayList：基于动态数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。 Queue ArrayDeque：双端队列。 Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。","link":"/2021/06/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E7%B1%BB/"},{"title":"游戏玩法分析","text":"题目描述游戏玩法分析 活动表 Activity： 12345678+--------------+---------+| Column Name | Type |+--------------+---------+| player_id | int || device_id | int || event_date | date || games_played | int |+--------------+---------+ 表的主键是 (player_id, event_date)。这张表展示了一些游戏玩家在游戏平台上的行为活动。每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后 打开的游戏的数目（可能是 0 个）。 写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。查询结果的格式如下所示: 12345678910111213141516171819Activity 表：+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-05-02 | 6 || 2 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result 表：+-----------+-------------+| player_id | first_login |+-----------+-------------+| 1 | 2016-03-01 || 2 | 2017-06-25 || 3 | 2016-03-02 |+-----------+-------------+ 解决方案12SELECT player_id, min(event_date) first_login FROM Activity GROUP BY player_id; 题目描述 写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。查询结果的格式如下所示: 12345678910111213141516171819Activity table:+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-05-02 | 6 || 2 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result table:+-----------+-----------+| player_id | device_id |+-----------+-----------+| 1 | 2 || 2 | 3 || 3 | 1 |+-----------+-----------+ 解决方案1234SELECT player_id,device_id FROM Activity WHERE (player_id, event_date)IN (SELECT player_id, min(event_date) first_loginFROM Activity GROUP BY player_id ); 题目描述 编写一个 SQL 查询，同时报告每组玩家和日期，以及玩家到目前为止玩了多少游戏。也就是说，在此日期之前玩家所玩的游戏总数。详细情况请查看示例。查询结果格式如下所示： 12345678910111213141516171819202122232425Activity table:+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-05-02 | 6 || 1 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result table:+-----------+------------+---------------------+| player_id | event_date | games_played_so_far |+-----------+------------+---------------------+| 1 | 2016-03-01 | 5 || 1 | 2016-05-02 | 11 || 1 | 2017-06-25 | 12 || 3 | 2016-03-02 | 0 || 3 | 2018-07-03 | 5 |+-----------+------------+---------------------+对于 ID 为 1 的玩家，2016-05-02 共玩了 5+6=11 个游戏，2017-06-25 共玩了 5+6+1=12 个游戏。对于 ID 为 3 的玩家，2018-07-03 共玩了 0+5=5 个游戏。请注意，对于每个玩家，我们只关心玩家的登录日期。 解决方案12345678910SELECT a1.player_id,a1.event_date,sum(a2.games_played) games_played_so_farFROMactivity a1,activity a2WHEREa1.player_id=a2.player_idANDa1.event_date&gt;=a2.event_dateGROUP BY a1.player_id,a1.event_dateORDER BY player_id,event_date 题目描述 编写一个 SQL 查询，报告在首次登录的第二天再次登录的玩家的比率，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。查询结果格式如下所示： 123456789101112131415161718Activity table:+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-03-02 | 6 || 2 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result table:+-----------+| fraction |+-----------+| 0.33 |+-----------+只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33 解决方案1234SELECT ROUND(sum(case when datediff(a.event_date,b.first_date)=1 then 1 else 0 end)/(select count(distinct(player_id)) from activity),2) as fractionfrom activity a,(select player_id,min(event_date) first_date from activity group by player_id) bwhere a.player_id=b.player_id","link":"/2021/06/20/%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E5%88%86%E6%9E%90/"}],"tags":[{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"阿里云","slug":"阿里云","link":"/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Flink SQL","slug":"Flink-SQL","link":"/tags/Flink-SQL/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Collections","slug":"Collections","link":"/tags/Collections/"}],"categories":[{"name":"技能","slug":"技能","link":"/categories/%E6%8A%80%E8%83%BD/"},{"name":"系统设计","slug":"系统设计","link":"/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"大数据","slug":"大数据","link":"/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"}]}