{"pages":[{"title":"","text":"","link":"/README.html"}],"posts":[{"title":"JVM - 理解Java 内存区域和溢出异常","text":"本文主要梳理了 JVM 内存区域相关知识点，同时分析了内存溢出异常的情况及常见JVM参数。 JVM - Java 内存区域运行时数据区域程序计数器(Program Counter Register) 描述：较小的内存空间，可理解为当前线程所执行的字节码的行号指示器 作用：字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，如：分支、循环、跳转、异常处理等 特点：多线程下每条线程都有一个独立的程序计数器，且互不影响，独立存储 注意：当执行 Native 方法时，计数器值为空(Undefined) Java 虚拟机栈(Java Virtual Machine Stack) 描述：线程私有，生命周期同线程 作用：存储局部变量表、操作数栈、动态连接、方法出口等 局部变量表：存放编译器可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、float)，其中(long、double)占用两个局部变量槽(slot)及对象引用(reference类型) 本地方法栈(Native Method Stack) 描述：本地方法栈是为虚拟机使用到的本地(Native)方法服务 作用：本地方法被执行的时候，在本地方法栈会创建一个栈帧，来存储局部变量表、操作数栈、动态连接、方法出口 Java 堆(Java Heap) 描述：虚拟机所管理的内存最大的一块 作用：存放对象实例，”几乎“所有的对象实例都在此分配 特点：Java堆是垃圾收集器管理的主要区域，因此成为 GC 堆 方法区(Method Area [Non-Heap]) 描述：用于存储已被虚拟机加载的类型信息、常量、静态变量等数据 运行时常量池(Runtime Constant Pool) 描述：是方法区的一部分。 作用：将除Class文件中类的版本、字段、方法、接口等描述信息，常量池表存放编译期生成的各种字面量与符号引用 直接内存(Direct Memory) 描述：JDK1.4中NIO类，引入一种基于(Channel)与缓冲区(Buffer)的I/O方式，可以使用Native函数直接分配堆外内存，通过存储在Java堆中DirectByteBuffer对象作为这块内存的引用来进行操作。某些场景提高性能，避免了Java堆和Native堆中来回复制数据 HotSpot虚拟机对象探秘对象创建过程 类加载检查 new 指令，检查常量池是否有符号引用，且是否被加载过、解析和初始化过 分配内存 指针碰撞(Bump The Pointer) 使用场景：堆内存规整(无碎片) 原理：用过的内存全部整合到一边，没有用的内存放到一边，中间放一个指针作为分界点的指示器，分配内存就仅仅吧指针向空闲方向挪动对象大小相等的距离 GC收集器：Serial、ParNew，简单高效 空闲列表(Free List) 使用场景：堆内存不规整 原理：虚拟机维护一个列表，列表中记录哪些内存块是可用的，分配时，找一块足够大的空间分配给对象，并更新列表记录 内存分配并发问题 CAS + 失败重试保证更新操作的原子性 TLAB(Thread Local Allocation Buffer) 初始化零值 保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序访问到是这些字段的数据类型所对应的零值 设置对象头 对象头中存储对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息 执行init方法 对象内存布局 对象头(Header) 运行时数据：哈希码、GC分代年龄、锁状态标志等 类型指针：对象指向它的类型元数据的指针 实例数据(Instance Data) 对象真正存储的有效信息 对齐填充(Padding) 不是必然存在，只是占位，因为对象头起始地址必须是8字节的整数倍 对象访问定位 使用句柄 Java堆中划分一块内存作为句柄池，reference中存储对象的句柄地址，句柄中存储包含对象实例数据与类型数据的各自具体地址信息 优势：存储的是稳定的句柄地址，对象被移动只会改变句柄中的实例数据指针 直接指针 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址 优势：速度快，节省一次指针定位的时间开销 Java 虚拟机异常情况StackOverFlowError 线程请求的栈深度大于虚拟机所允许的深度 OutOfMemoryError Java虚拟机栈、本地方法栈容量扩展时无法申请足够的内存 Gc Overhead Limit Exceeded:当JVM花太多时间执行垃圾回收且只能收回很少的堆空间 Java Heap Space：在创建新的对象是，堆内存中空间不足以存放新创建的对象(通过-Xmx和-Xms设定) 运行时常量池无法再申请到内存 当各个内存区域综合大于物理内存限制，从而导致动态扩展失败 重要JVM参数堆内存 -Xms：最小堆 -Xmx：最大堆 -XX:NewSize：初始化新生代 -XX:MaxNewSize：新生代最大 -XX:PermSize：初始化永久代 -XX:MaxPermSize：永久代最大 -XX:MetaspaceSize：初始化元空间 -XX:MetaspaceSize：元空间最大 垃圾收集 -XX:+UserSerialGC：串行垃圾收集器 -XX:+UserParallelGC：并行垃圾收集器 -XX:+UserParNewGC：CMS垃圾收集器 -XX:+UserG1GC：G1垃圾收集器","link":"/2021/08/01/JVM-%E7%90%86%E8%A7%A3Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"},{"title":"LeetCode--反转链表","text":"206.反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例1 12输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例2 12输入：head = [1,2]输出：[2,1] 示例312输入：head = []输出：[] Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ListNode { int val; ListNode next; ListNode() { } ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } public static void main(String[] args) { ListNode head = new ListNode(1, new ListNode(2, new ListNode(3))); ListNode reverseList = reverseList(head); while (Objects.nonNull(reverseList)) { System.out.println(reverseList.val); reverseList = reverseList.next; } } /** * 迭代方式 * * @param head * @return */ public static ListNode reverseList(ListNode head) { if (head == null) { return null; } ListNode prev = null; while (head != null) { ListNode next = head.next; head.next = prev; prev = head; head = next; } return prev; }}","link":"/2021/08/01/LeetCode-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"Netty 实战- Netty 的概念及体系结构","text":"Netty 的概念及体系结构Netty–异步和事件驱动 Netty 提供了极丰富的网络编程工具集，但其只是一个框架，它的架构方法和设计原则是：每一个笑点都和它的技术内容一样重要。 关注点分离—-业务和网络逻辑解耦 模块化和可复用性 可测试性味首要的要求 Java 网络编程&nbsp;&nbsp;&nbsp;&nbsp;早期的 Java API（java.net）只支持本地系统的套接字库来提供所谓的阻塞函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package nia.chapter1;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class BlockingIoExample {/*** 代码清单 1-1 阻塞 I/O 示例* */public void serve(int portNumber) throws IOException {//创建一个新的 ServerSocket，用以监听指定端口上的连接请求ServerSocket serverSocket = new ServerSocket(portNumber);//对accept()方法的调用将被阻塞，直到一个连接建立Socket clientSocket = serverSocket.accept();//这些流对象都派生于该套接字的流对象BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));PrintWriter out =new PrintWriter(clientSocket.getOutputStream(), true);String request, response;//处理循环开始while ((request = in.readLine()) != null) {if (&quot;Done&quot;.equals(request)) {break;}//请求被传递给服务器的处理方法response = processRequest(request);//服务器的响应被发送给了客户端out.println(response);//继续执行处理循环}}private String processRequest(String request){return &quot;Processed&quot;;}} Java NIOJava 对非阻塞I/O的支持在JDK1.4的 java.nio包中。 选择器java.nio.channels.Selector 是Java的非阻塞I/O实现的关键。使用了事件通知API以确定一组非阻塞套接字中农有哪些已经就绪能够进行I/O相关操作。 使用较少的县城可以处理许多连接，因此也减少了内存管理和上下文切换带来的开销 当没有I/O操作需要的时候，线程可以用于其他任务 Netty 简介 想要实现更高的吞吐量和可扩展性，在更低的成本基础上进行交付。如果直接使用底层的API，显得较为复杂。在网络编程领域，Netty是 Java的卓越框架。它驾驭了Java高级API的能力，并将其隐藏在一个易于使用的API之后。其特性主要体现在以下。 设计：统一的API，支持多种传输类型，阻塞和非阻塞，简单而强大的线程模型，真正的无连接数据报套接字支持，链接逻辑组建以支持复用 易于使用：详实的文档和示例集 性能：拥有比Java的核心API更高的吞吐量以及更低的延迟，得益于池化和复用，拥有更低的资源消耗，最少的内存复制 健壮性：不会因为慢速、快速或者超载的连接导致OutOfMemoryError 安全性：完整的SSL/TLS支持 社区驱动：发布快速且频繁 异步和事件驱动异步和可伸缩性之间的联系： 非阻塞网络调用使我们可以不必等待一个操作的完成。完全异步的I/O正是基于这个特性构建的，异步方法会立即返回，并且在它完成时，会直接或者稍后的某个时间通知用户。 选择器是的我们能够通过较少的线程见识许多连接上的事件 Netty 的核心组件 Channel 回调 Future 事件和ChannelHandler 这些构建块代表了不同类型的构造：资源、逻辑以及通知。你的应用将使用它们来访问网络以及流经网络的数据。 ChannelChannel 是Java NIO 的一个基本构造。代表了一个实体的开放连接，如读操作和写操作。 回调回调其实就是一个方法，一个指向已经被提供给另一个方法的方法的引用。回调在广泛的编程场景中都有应用，而且是在操作完成后通知相关方最常见的方式。在Netty内部使用了回调来处理事件，当一个回调被触发时，相关事件可以被 ChannelHandler 接口实现来处理。 12345678910111213141516171819202122import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;public class ConnectHandler extends ChannelInboundHandlerAdapter {@Override//当一个新的连接已经被建立时，channelActive(ChannelHandlerContext)将会被调用public void channelActive(ChannelHandlerContext ctx)throws Exception {System.out.println(&quot;Client &quot; + ctx.channel().remoteAddress() + &quot; connected&quot;);}} FutureFuture 提供了另一种在操作完成时通知应用程序的方式。可以看做是异步操作的结果占位符；它将在未来的某个时刻完成，并提供对其结果的访问。每个 Netty 的出站I/O操作都返回一个ChannelFuture，也就是说都不会阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelFutureListener;import io.netty.channel.socket.nio.NioSocketChannel;import java.net.InetSocketAddress;import java.nio.charset.Charset;public class ConnectExample {private static final Channel CHANNEL_FROM_SOMEWHERE = new NioSocketChannel();public static void connect() {Channel channel = CHANNEL_FROM_SOMEWHERE; //reference form somewhere// Does not block//异步地连接到远程节点ChannelFuture future = channel.connect(new InetSocketAddress(&quot;192.168.0.1&quot;, 25));//注册一个 ChannelFutureListener，以便在操作完成时获得通知future.addListener(new ChannelFutureListener() {@Overridepublic void operationComplete(ChannelFuture future) {//检查操作的状态if (future.isSuccess()) {//如果操作是成功的，则创建一个 ByteBuf 以持有数据ByteBuf buffer = Unpooled.copiedBuffer(&quot;Hello&quot;, Charset.defaultCharset());//将数据异步地发送到远程节点。返回一个 ChannelFutureChannelFuture wf = future.channel().writeAndFlush(buffer);// ...} else {//如果发生错误，则访问描述原因的 ThrowableThrowable cause = future.cause();cause.printStackTrace();}}});}} 事件和 ChannelHandlerNetty 使用不同的事件通知我们状态的改变或者是操作的改变。使我们能够基于已经发生的事件来触发适当的动作。如： 记录日志 数据转换 流控制 应用程序逻辑 Netty 入站数据或者相关的状态变更而触发的事件包括： 连接已被激活或连接失活 数据读取 用户事件 错误事件 Netty 出站事件是未来将会触发的某个动作的操作结果,如： 打开或关闭到远程节点的连接 将数据写到或者冲刷到套接字","link":"/2021/08/03/Netty-%E5%AE%9E%E6%88%98-Netty-%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"title":"Redis In Action 笔记（一）","text":"本文是对 Redis In Action 一书的内容进行了个人知识的梳理和总结。 Redis 概念 Redis 是一个远程内存数据库，它提供了5种不同的类型的数据结构，可以支持复制、持久化和客户端分片等功能。 Redis同其他数据库之间的对比 Redis 数据结构 String 常见命令 List 常见命令 Hash 常见命令 Set 常见命令 SortedSet(ZSet) 常见命令 持久化及复制 持久化选项可以让用户将自己的数据存储到硬盘上面，复制特性保证更新数据副本存储到附加的机器上面，来提升系统的性能和数据的可靠性。 快照 Redis 通过创建快照来获得存储在内存里面的数据在某个时间点的副本。在创建快照后，用户可以对快照进行备份，将快照复制到其他服务器从而创建具有相同的数据的服务器副本，也可以将快照留在原地以便重启服务器使用。 AOF AOF 持久化将被执行的写命令写到AOF文件的尾部，来记录数据发生的变化。","link":"/2021/06/27/Redis-In-Action-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"开发者知识技能树","text":"知识点梳理 改栏目主要用于梳理开发者常见技能。","link":"/2021/06/20/%E5%BC%80%E5%8F%91%E8%80%85%E7%9F%A5%E8%AF%86%E6%8A%80%E8%83%BD%E6%A0%91/"},{"title":"深入理解Java集合类","text":"理解Java集合 Java集合工具类继承关系图。从下图中能发现Map并没有实现Collection接口，其实现了Map接口。 Iterable 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。 Collection 继承Iterable接口，不能被实例化。 List ArrayList：基于动态数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。 Queue ArrayDeque：双端队列。 Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。","link":"/2021/06/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E9%9B%86%E5%90%88%E7%B1%BB/"},{"title":"游戏玩法分析","text":"题目描述游戏玩法分析 活动表 Activity： 12345678+--------------+---------+| Column Name | Type |+--------------+---------+| player_id | int || device_id | int || event_date | date || games_played | int |+--------------+---------+ 表的主键是 (player_id, event_date)。这张表展示了一些游戏玩家在游戏平台上的行为活动。每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后 打开的游戏的数目（可能是 0 个）。 写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。查询结果的格式如下所示: 12345678910111213141516171819Activity 表：+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-05-02 | 6 || 2 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result 表：+-----------+-------------+| player_id | first_login |+-----------+-------------+| 1 | 2016-03-01 || 2 | 2017-06-25 || 3 | 2016-03-02 |+-----------+-------------+ 解决方案12SELECT player_id, min(event_date) first_login FROM Activity GROUP BY player_id; 题目描述 写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。查询结果的格式如下所示: 12345678910111213141516171819Activity table:+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-05-02 | 6 || 2 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result table:+-----------+-----------+| player_id | device_id |+-----------+-----------+| 1 | 2 || 2 | 3 || 3 | 1 |+-----------+-----------+ 解决方案1234SELECT player_id,device_id FROM Activity WHERE (player_id, event_date)IN (SELECT player_id, min(event_date) first_loginFROM Activity GROUP BY player_id ); 题目描述 编写一个 SQL 查询，同时报告每组玩家和日期，以及玩家到目前为止玩了多少游戏。也就是说，在此日期之前玩家所玩的游戏总数。详细情况请查看示例。查询结果格式如下所示： 12345678910111213141516171819202122232425Activity table:+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-05-02 | 6 || 1 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result table:+-----------+------------+---------------------+| player_id | event_date | games_played_so_far |+-----------+------------+---------------------+| 1 | 2016-03-01 | 5 || 1 | 2016-05-02 | 11 || 1 | 2017-06-25 | 12 || 3 | 2016-03-02 | 0 || 3 | 2018-07-03 | 5 |+-----------+------------+---------------------+对于 ID 为 1 的玩家，2016-05-02 共玩了 5+6=11 个游戏，2017-06-25 共玩了 5+6+1=12 个游戏。对于 ID 为 3 的玩家，2018-07-03 共玩了 0+5=5 个游戏。请注意，对于每个玩家，我们只关心玩家的登录日期。 解决方案12345678910SELECT a1.player_id,a1.event_date,sum(a2.games_played) games_played_so_farFROMactivity a1,activity a2WHEREa1.player_id=a2.player_idANDa1.event_date&gt;=a2.event_dateGROUP BY a1.player_id,a1.event_dateORDER BY player_id,event_date 题目描述 编写一个 SQL 查询，报告在首次登录的第二天再次登录的玩家的比率，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。查询结果格式如下所示： 123456789101112131415161718Activity table:+-----------+-----------+------------+--------------+| player_id | device_id | event_date | games_played |+-----------+-----------+------------+--------------+| 1 | 2 | 2016-03-01 | 5 || 1 | 2 | 2016-03-02 | 6 || 2 | 3 | 2017-06-25 | 1 || 3 | 1 | 2016-03-02 | 0 || 3 | 4 | 2018-07-03 | 5 |+-----------+-----------+------------+--------------+Result table:+-----------+| fraction |+-----------+| 0.33 |+-----------+只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33 解决方案1234SELECT ROUND(sum(case when datediff(a.event_date,b.first_date)=1 then 1 else 0 end)/(select count(distinct(player_id)) from activity),2) as fractionfrom activity a,(select player_id,min(event_date) first_date from activity group by player_id) bwhere a.player_id=b.player_id","link":"/2021/06/20/%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E5%88%86%E6%9E%90/"},{"title":"设计千万级用户排名系统","text":"场景 某海量用户网站，用户拥有积分，积分可能会在使用过程中随时更新。现在要为该网站设计一种算法，在每次用户登录时显示其当前积分排名。用户最大规模为2亿；积分为非负整数，且小于100万。 设计思路解决方案存在问题","link":"/2021/06/11/%E8%AE%BE%E8%AE%A1%E5%8D%83%E4%B8%87%E7%BA%A7%E7%94%A8%E6%88%B7%E6%8E%92%E5%90%8D%E7%B3%BB%E7%BB%9F/"},{"title":"设计模式","text":"","link":"/2021/07/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"阿里云Flink实时计算DEMO","text":"统计网站实时充值数据情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136-- 日志CREATE TEMPORARY TABLE sls_table_temp ( __event__ STRING, __event__app__ STRING, __event__time__ BIGINT, ts AS TO_TIMESTAMP (FROM_UNIXTIME (__event__time__)), WATERMARK FOR ts AS ts - INTERVAL '2' SECOND --为Rowtime定义Watermark。 )with ( 'connector' = 'sls', 'endpoint' = '', 'accessId' = '', 'accessKey' = '', 'project' = '', 'logstore' = '', 'startTime' = '' );-- 订单表CREATE TEMPORARY VIEW order_table_temp ASSELECT event_name, JSON_VALUE (event_str, '$.et.ai.si') AS site_id, JSON_VALUE (event_str, '$.et.ai.li') AS link_id, JSON_VALUE (event_str, '$.et.kv.orderNum') AS order_num, JSON_VALUE (event_str, '$.et.kv.amount') AS amount, JSON_VALUE (event_str, '$.et.kv.chapterId') AS chapter_id, JSON_VALUE (event_str, '$.et.kv.activityId') AS activity_id, JSON_VALUE (event_str, '$.et.kv.pushId') AS push_id, JSON_VALUE (event_str, '$.et.kv.page') AS page, JSON_VALUE (event_str, '$.et.kv.type') AS order_type, JSON_VALUE (event_str, '$.et.kv.bookId') AS book_id, FROM_UNIXTIME ( CAST ( JSON_VALUE (event_str, '$.et.kv.orderTime') AS BIGINT ) / 1000 ) order_time, appfrom ( select __event__ AS event_str, JSON_VALUE (__event__, '$.app') AS app, JSON_VALUE (__event__, '$.et.en') AS event_name from sls_table_temp )where app = 'matrix_app' AND event_name = 'order';-- 充值表CREATE TEMPORARY VIEW recharge_table_temp ASSELECT event_name, JSON_VALUE (event_str, '$.et.kv.isFirst') AS is_first, JSON_VALUE (event_str, '$.et.kv.uid') AS user_id, JSON_VALUE (event_str, '$.et.kv.orderNum') AS order_num, JSON_VALUE (event_str, '$.et.kv.status') AS recharge_status, FROM_UNIXTIME ( CAST ( JSON_VALUE (event_str, '$.et.kv.rechargeTime') AS BIGINT ) / 1000 ) recharge_time, appfrom ( select __event__ AS event_str, JSON_VALUE (__event__, '$.app') AS app, JSON_VALUE (__event__, '$.et.en') AS event_name from sls_table_temp )where app = 'matrix_app' AND event_name = 'recharge';-- 双表联合CREATE TEMPORARY VIEW user_order_recharge_temp ASselect *from order_table_temp o left join recharge_table_temp r on o.order_num = r.order_num;-- 统计SELECT site_id, SUM ( CASE WHEN recharge_status = 1 AND order_type = 'normal' THEN amount ELSE 0 END ) normal_recharge_amount, COUNT ( DISTINCT CASE WHEN recharge_status = 1 AND order_type = 'normal' THEN user_id END ) normal_recharge_users, SUM ( CASE WHEN recharge_status = 1 AND order_type = 'normal' THEN 1 ELSE 0 END ) normal_orders, SUM ( CASE WHEN recharge_status IS NULL AND order_type = 'normal' THEN 1 ELSE 0 END ) normal_orders_not_pay, SUM ( CASE WHEN recharge_status = 1 AND order_type = 'monthly' THEN amount ELSE 0 END ) vip_recharge_amount, COUNT ( DISTINCT CASE WHEN recharge_status = 1 AND order_type = 'monthly' THEN user_id END ) vip_recharge_users, SUM ( CASE WHEN recharge_status = 1 AND order_type = 'monthly' THEN 1 ELSE 0 END ) vip_orders, SUM ( CASE WHEN recharge_status IS NULL AND order_type = 'monthly' THEN 1 ELSE 0 END ) vip_orders_not_payfrom user_order_recharge_tempgroup by site_id;","link":"/2021/06/21/%E9%98%BF%E9%87%8C%E4%BA%91Flink%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97DEMO/"}],"tags":[{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"Netty","slug":"Netty","link":"/tags/Netty/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Collections","slug":"Collections","link":"/tags/Collections/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"阿里云","slug":"阿里云","link":"/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Flink SQL","slug":"Flink-SQL","link":"/tags/Flink-SQL/"}],"categories":[{"name":"JVM","slug":"JVM","link":"/categories/JVM/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Netty","slug":"Netty","link":"/categories/Netty/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"技能","slug":"技能","link":"/categories/%E6%8A%80%E8%83%BD/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"系统设计","slug":"系统设计","link":"/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"大数据","slug":"大数据","link":"/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]}